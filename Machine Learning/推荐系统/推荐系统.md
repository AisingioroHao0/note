# 推荐系统

以电影推荐系统举例。

每个电影i会对  应一个特征向量，如动作评分，剧情评分等。

每个电影n个特征，有$n_u$个用户,$n_m$个电影

每个用户j对应一个$w^{(j)}$以及$b^{(j)}$，用户对该电影的预测评分为$y^{(i,j)}=w^{(j)}\cdot x^{(i)}+b^{(j)}$

如果用户j对电影i评分了，则r(i,j)=1，否则r(i,j)=0

## 协同过滤算法

多个用户协同评价一个电影并且为电影选出最合适的特征

使用用户的评价帮助学习电影的特征x，同时用x帮助学习用户的预测参数w，b。

假设w，b已知，去学习$x^{(i)}$,那么
$$
J(x^{(i)})=\frac{1}{2}\sum_{j=1}^{n_u}(w^{(j)}\cdot x^{(i)}+b^{(j)}-y^{(i,j)})^2+\frac{\lambda}{2}\sum_{k=1}^n(x_k^{(i)})^2 \\
J(x)=\frac{1}{2}\sum_{i=1}^{n_m}\sum_{j:r(i,j)=1}(w^{(j)}\cdot x^{(i)}+b^{(j)}-y^{(i,j)})^2+\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n(x_k^{(i)})^2 \hfill
$$
假设x以知，学习w，b，那么
$$
J(w,b)=\frac{1}{2}\sum_{j=1}^{n_u}\sum_{i:r(i,j)=1}^{n_m}(w^{(j)}\cdot x^{(i)}+b^{(j)}-y^{(i,j)})^2+\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^n(w_k^{(i)})^2
$$
和并得
$$
J(w,b,x)=\frac{1}{2}\sum_{(i,j):r(i,j)=1}(w^{(j)}\cdot x^{(i)}+b^{(j)}-y^{(i,j)})^2+\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^n(w_k^{(i)})^2+\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n(x_k^{(i)})^2
$$

### 二进制特征

对于预测y(i,j)=1的可能性改为g(z)，g为sigmoid 函数，z=wx+b。

同时修改loss function为：
$$
L(f(x),y)=-ylog(f(x))-(1-y)log(1-f(x))
$$
类似于二元分类

### cost function实现

```python
def cofi_cost_func_v(X, W, b, Y, R, lambda_):
    """
    Returns the cost for the content-based filtering
    Vectorized for speed. Uses tensorflow operations to be compatible with custom training loop.
    Args:
      X (ndarray (num_movies,num_features)): matrix of item features
      W (ndarray (num_users,num_features)) : matrix of user parameters
      b (ndarray (1, num_users)            : vector of user parameters
      Y (ndarray (num_movies,num_users)    : matrix of user ratings of movies
      R (ndarray (num_movies,num_users)    : matrix, where R(i, j) = 1 if the i-th movies was rated by the j-th user
      lambda_ (float): regularization parameter
    Returns:
      J (float) : Cost
    """
    j = (tf.linalg.matmul(X, tf.transpose(W)) + b - Y)*R
    J = 0.5 * tf.reduce_sum(j**2) + (lambda_/2) * (tf.reduce_sum(X**2) + tf.reduce_sum(W**2))
    return J
```

### tensorflow实现

数据为https://grouplens.org/datasets/movielens/latest/

#### 引入包

```python
import numpy as np
import numpy.ma as ma
import pandas as pd
import tensorflow as tf
from tensorflow import keras
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.model_selection import train_test_split
import tabulate
```



```python
import tensorflow as tf
from tensorflow import keras
optimizer=keras.optimizers.Adam(learning_rate=1e-1)

iterations=200
for iter in range(iterations):
    with tf.GradientTape() as Tape:
        cost_value = cofiCostFuncV(X,W,b,ynorm,R,num_users,num_movies,lambda)

    grads=tape.gradient(cost_value,[X,W,b])

    optimizer.apply_gradients(zip(grads,[X,W,b]))
```



## 均值归一化

假设有一个从为参与人和评分的用户，他的w，b初始为0,cost函数的第一项不会对结果作出任何贡献，那么由正则化项，会使w，b永远为0，预测也将是0分。为了更好的估计用户，需要使用均值归一化。

![image-20230218000141032](./%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230218000141032.png)

计算每部电影，用户对其评分的平均值$\mu$，并在训练时，使用每个用户改电影的评分减$\mu$进行训练，预测将是用户该电影的平均评分

![image-20230218003140040](./%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230218003140040.png)

## 基于内容的过滤算法

基于内容得过滤关键在于，充分利用用户与电影的特征找到比纯粹的协同过滤方法可能更好的匹配。

用户的特征向量维度和电影的特征向量维度差异可能是非常大的，该算法通过神经网络将他们映射到同样的维度。

用户的特征会转变为$v_u$，电影的特征转换为$v_m$，最后用$v_u \cdot v_m+b$来预测

可以寻找到类似的电影通过$(v_m^{(k)}-v_m^{(i)})^2$

### tensorflow实现

```python
# GRADED_CELL
# UNQ_C1

num_outputs = 32
tf.random.set_seed(1)
user_NN = tf.keras.models.Sequential([
    ### START CODE HERE ###     
  tf.keras.layers.Dense(256,activation='relu'),
  tf.keras.layers.Dense(128,activation='relu'),
  tf.keras.layers.Dense(num_outputs),
  
  
    ### END CODE HERE ###  
])

item_NN = tf.keras.models.Sequential([
    ### START CODE HERE ###     
  tf.keras.layers.Dense(256,activation='relu'),
  tf.keras.layers.Dense(128,activation='relu'),
  tf.keras.layers.Dense(num_outputs),
  
  
    ### END CODE HERE ###  
])

# create the user input and point to the base network
input_user = tf.keras.layers.Input(shape=(num_user_features))
vu = user_NN(input_user)
vu = tf.linalg.l2_normalize(vu, axis=1)

# create the item input and point to the base network
input_item = tf.keras.layers.Input(shape=(num_item_features))
vm = item_NN(input_item)
vm = tf.linalg.l2_normalize(vm, axis=1)

# compute the dot product of the two vectors vu and vm
output = tf.keras.layers.Dot(axes=1)([vu, vm])

# specify the inputs and output of the model
model = tf.keras.Model([input_user, input_item], output)

model.summary()
```



## many law scale recommended system

为了实现内容量极其庞大的推荐系统。该算法将推荐划分为了检索和排名两个部分：

- 检索（Retrieval）:

  - 生成可能的的推荐产品列表
  - 和并成一个列表，并去掉已经看过或购买过的

- 排名（Ranking）

  使用学习系统进行排名
