#  同步

## 临界区问题

修改公共变量，更新一个表，写一个文件等操作可能引发并发问题的代码区域。

当一个进程在临界区执行时，其他进程不允许在他们的临界区内执行。

解决方案应满足如下三条要求：

- 互斥

- 进步

  如果没有进程在其临界区内执行，并且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可以参加选择，以便确定谁能下次进入临界区，这种选择不能无限推迟

- 有限等待

  从一个进程做出临界区请求直到这个请求允许为止，其他进程允许进入其临界区的次数具有上限。

解决方案：

- 非抢占式内核

  基本不会导致竞争条件

- 抢占式内核

  需要认真确保内核数据结构不会导致竞争条件

## Peterson解决方案

用一个变量turn表示哪个进程可以进入临界区。

## 硬件同步

利用硬件指令同步

## 互斥锁

## 信号量

### 死锁与饥饿

### 优先级反转

因为锁等同步机制，优先级较高的进程不得不等待优先级较低的进程用完资源。

## 管程

抽象数据类型（ADT，Abstract Data Type）封装了数据以及对其操作的一组函数，这一类型独立于任何特定的ADT实现。管程类型（monitor type）属于ADT类型，提供一组由程序员定义的，在管程内互斥的操作。

管程结构确保每次只有一个进程在管程内处于活动状态。