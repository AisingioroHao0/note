# 内存管理策略

内存由一个很大的字节数组组成，每个字节都有各自的地址。

CPU根据程序计数器的值从内存中提取指令，然后指令被解码，也可能需要从内存中读取操作数，结果可能存回内存。

## 基本硬件

CPU可以直接访问的通用存储只有内存和处理器内置的寄存器。

机器指令可以用内存地址作为参数，而不能用磁盘地址作为参数。

如果数据不在内存中，那么在CPU使用他们前应先把数据移动到内存中。

### 保护机制

- 基地址寄存器

  含有最小的合法的物理内存地址

- 界限地址寄存器

  制定了范围大小

### 地址绑定

进程在执行时可以在磁盘和内存之间移动。

在磁盘上等待调到内存以便执行的进程形成了输入队列。

源程序的地址通常是符号表示。

编译器通常将这些符号地址绑定到可重定位的地址（偏移量型地址）。

链接程序或加载程序再将这些可重定位的地址绑定到绝对地址。

通常，指令和数据绑定到存储器地址可在沿途的任何一步中进行：

- 编译时

  如果在编译时就已经知道进程将在内存中驻留的地址，那么就可以生成绝对代码。

  将来若开始地址有变化有必要重新编译代码。

  不知道则生成可重定位代码。

- 加载时

  可重定位代码，绑定

- 执行时

### 逻辑地址空间与物理地址空间

CPU生成的地址通常称为逻辑地址（虚拟地址）。

内存单元看到的地址（即加载到内存地址寄存器的地址）通常为物理地址。

从虚拟地址到物理地址的运行时映射时由内存管理单元（MMU，Memory-Management Unit)的硬件设备来完成的。

#### 重定位寄存器

基地址寄存器在这里称为重定位寄存器。

用户进程所生成的地址在送交内存之前，都将加上重定位寄存器的值。

### 动态加载

程序只由在调用时才会加载。

所有程序都以可重定位加载格式保存在磁盘上。

### 动态链接与共享库

动态链接库（dll，dynamically linked library）为系统库，可链接到用户程序，以便运行，加载延迟到运行时。

如果由动态链接，二进制程序映像内，每个库程序的引用都有一个存根。

存根是一小段代码，用来指出如何定位适当的内存驻留库程序，或者在程序不在内存内应如何加载库。

## 交换

进程必须在内存中以便执行。不过进程可以在是从内存交换到备份存储，当再执行时再调回到内存中。

### 标准交换

标准交换在内存与备份存储之间移动进程。

备份存储通常是快速磁盘。

### 移动系统的交换

移动系统往往不支持交换。

## 连续内存分配

每个进程位于一个连续的内存区域。

### 内存保护

CPU产生的每个地址都要与重定位寄存器和界限寄存器核对。

### 内存分配

将内存分为多个固定大小的分区。

每个分区只可以包含一个进程。

对于可变分区方案，操作系统有一个表，用于记录哪些内存可用或那些内存已用

一大块可用的内存称为一个孔（hole）

分配孔的方案：

- 首次适应

  分配首个足够大的孔

- 最优适应

  分配最小的足够大的孔

- 最差适应

  分配最大的孔

### 碎片

随着进程加载到内存和从内存退出，空闲的内存空间被分为小的片段。

解决方案：

- 紧缩
- 允许进程的逻辑空间地址不连续

## 分段

### 基本方法

逻辑地址空间是由一组段构成。

每个段都有名称和长度。

地址制定了段名称和段偏移。

### 分段硬件

#### 段表

映射用户定义的二位地址到一维物理地址。

每个条目都有段基地址以及段界限。

## 分页

避免了外部碎片与紧缩。

避免了将不同大小的内存块匹配到交换空间的麻烦问题。

存在内部碎片，当进程所需的内存不是页的整数倍，最后一帧可能用不完。

增加了上下文切换的时间。

### 基本方法

将物理内存分为固定大小的块，称为帧或页帧。

将逻辑内存分为同样大小的块，称为页或页面。

由CPU生成的每个地址包含两部分：

- 页码
- 页偏移

帧表：物理内存的细节

当一个进程分配到CPU时，CPU分派其页根据该副本来定义硬件页表，因此，增加了上下文切换的时间

### 硬件支持

有的操作系统为每个进程分配一个页表。页表的指针，与其他寄存器的值（如指令寄存器）一起存入进程控制块。

当分派器需要启动一个进程时，它应首先加载用户寄存器，并根据保存的用户页表来定义正确的硬件页表值。

页表的硬件实现有多种方法：

- 将页表作为一组专用的寄存器来实现

  页表比较小时

- 页表基地址寄存器

  页表存于内存中，页表基地址寄存器指向页表

性能提高方案：

- 转换表缓冲区

### 保护

分页环境下的内存保护使用过每个帧关联的保护位来实现的。通常这些保护位位于页表之中。

### 共享页

共享共用代码，物理内存只需保存一个编译器副本。

## 页表结构

### 分层分页

二层分页 四层分页

### 哈希页表

采用虚拟页码作为哈希值。

哈希页表的每一个条目都包括一个链表，该链表的元素哈希到同一位置。

虚拟地址的虚拟页码哈希到哈希表，用虚拟页码与链表内的第一个元素的第一个字段比较，

如果匹配那么相应的帧码（第二个字段）就用来形成物理地址。

如果不匹配，那么与链表内的后续节点的第一个字段进行比较，以查找匹配的页码。

### 倒置页表

对于每个真正的内存页或帧，导致页表才有一个条目，这个条目包含在真正内存位置上的页的虚拟地址，以及拥有该页进程的信息。