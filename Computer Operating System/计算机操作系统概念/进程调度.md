# 进程调度

## 基本概念

多个进程同时处于内存，当一个进程等待时，操作系统就从改进程接管CPU控制，并将CPU交给另一个进程

### CPU-I/O执行周期

进程执行包括周期进行：CPU执行和I/O执行

### CPU调度程序

短期调度程序或CPU调度程序

### 抢占调度

需要进行CPU调度的情况可分为以下四种：

- 运行->等待

  例如：I/O请求,wait()调用等待子进程终止

- 运行->就绪

  例如：出现中断

- 等待->就绪

  例如：I/O完成

- 终止

对于调度只发生在第一和第四种时，这种调度方案时非抢占的。

否则这种调度方案时抢占的。

非抢占调度方案下进程会一直使用CPU，直到终止或切换到等待状态。

## 调度程序

调度程序是一个模块，用来将CPU控制交给由短期调度程序选择的进程

### 功能

- 切换上下文
- 切换到用户模式
- 跳转到用户程序的合适位置

### 调度算法比较准则

- CPU使用率

  CPU应尽可能的忙碌

- 吞吐量

  一个时间单元内进程完成的数量

- 周转时间

  进程提交到进程完成的时间段，包括

  等待进入内存，在就绪队列种等待，CPU执行以及I/O执行

- 等待时间

  CPU调度算法应不影响进程运行和执行I/O的时间。等待时间为在就绪队列种等待所花时间之和

- 响应时间

  对于交互系统，周转时间不是最佳准则。

  响应时间为从提交到第一次响应的时间

## 调度算法

### 先到先服务（FCFS,First-Come First_Served)

非抢占的

### 最短作业优先调度（SJF，Shortest-Job-First）

可以抢占可以非抢占

抢占SJF有手机称为最短剩余时间有限

### 优先级调度

主要问题是无穷阻塞或饥饿，低优先级的进程可能永远不会被运行

解决方案之一是老化

### 轮转调度（RR，Round-Robin）

专门为分时系统设计

依次为每个进程

### 多级队列调度

将就绪队列分成多个单独队列，每个队列有自己的调度算法。

进程进入系统时被永久的分配到某个队列。

队列之间应由调度，通常采用优先级调度抢占调度。

### 多级反馈队列调度

该调度算法允许进程在队列之间迁移

- 队列数量
- 每个队列的调度算法
- 用以确定何时升级到更高优先级队列的方法
- 用以确定何时降级到更低优先级队列的方法
- 用以确定进程在需要服务时将会进入哪个队列的方法

## 多处理器调度

### 多处理器调度的方法

对于多处理器系统，

#### 非对称处理（asymmetric multiprocessing）

一个处理器处理所有的调度决定，I/O处理以及其他系统活动。

其他处理器只执行用户代码。

#### 对称多处理（SMP，Symmetric MultiProcessing）：

每个处理器都有自己的私有就绪队列或所有进程处于一个共同的就绪队列种。

需仔细考虑不会由多个处理器处理同一进程。

### 处理器亲和性

进程迁移到其他处理器意味着原处理器缓存内容应设为无效，第二个处理器缓存应重新填充。

避免一个进程从一个处理器迁移到另一个处理器，试图让一个进程运行在同一个处理器上，这种称为处理器亲和性。

#### 非统一内存访问（NUMA，Non-Uniform Memory Access)

一个CPU访问内存的某些部分会比其他部分更快

当进程分配到一个特定的亲和处理器上时，进程的内存应分配到这个处理器能更块访问的内存区域。

### 负载均衡

通常当每个处理器有私有就绪队列时，需要考虑。

会抵消处理器亲和性所带来的优化。

一个特定的任务周期性的检查每个处理器的负载。

#### 推迁移

把进程从超载处理器push到空闲或不太忙的处理器。

#### 拉迁移

把进程从忙的处理器pull到空闲不太忙的服务器

### 多核处理器

#### 内存停顿

当一个处理器访问内存时，它花费大量时间等待所需数据，这种情况称为内存停顿。

原因如：高速缓存未命中。

为了解决这样的问题，硬件设计采用了多线程的处理器核，每个核会分配到多个线程

处理器的多线程有两种办法：

- 粗粒度

  线程一直在处理器上运行，直到一个长延迟事件（如内存停顿）发生

- 细粒度

  多线程在更细粒度级别上切换线程

注意一个多线程多核处理器实际需要两个不同级别的调度：

- 一个级别的调度决策由操作系统做出，用于选择哪个软件线程运行在哪个硬件线程
- 另一个级别的调度决策指定每个核如何决定运行哪个硬件线程

## 实时CPU调度

- 软实时系统

  不保证会调度关键实时进程，而只保证这类进程会优先于非关键进程。

- 硬实时系统

  一个任务应在它的截止期限之前完成；

  在截止日期之后完成，与没有完成，是完全一样的

### 最小化延迟

考虑实时系统的事件驱动性质，通常这种系统等待一个实时事件的发生。

事件延迟：从事件发生到事件得到服务的这段时间

#### 中断延迟

从CPU收到中断到中断程序开始的时间称为中断延迟。

当一个中断发生时，操作系统应先完成正在执行的指令，再确定发生中断的类型。然后，它应保存当前进程的状态，再采用特定的中断服务程序（ISR，Interrupt Service Routine）处理中断

影响中断延迟的一个重要因素是：在更新内核数据结构时中断可能会被禁用的时间量。

#### 调度延迟

调度程序重停止一个进程到启动另一个进程所需的时间量称为调度延迟。

保持低调用延迟的最有效技术时抢占式内核。

调用延迟的冲突阶段有两个部分：

- 抢占在内核中运行的任何进程
- 释放高优先级进程所需的，低优先级进程占有的资源。

### 优先级调度

实时操作系统的最重要功能是：当一个实时进程需要CPU时，立即响应。

进程时周期性的需要CPU：

- 有固定的处理时间t

- CPU应处理的截止期限d

- 周期p

- 周期任务的速率为1/p

可以根据这些参数设置优先级

#### 准入控制

- 承认进程，保证进程完成
- 如果它不能保证任务能在截止期限前得以服务，拒绝请求

### 单调速率调度

采用抢占的，静态优先级的策略，调度周期性的额任务。

当进程进入系统时，每个周期性任务会分配一个优先级，它与周期成反比。

较高优先级进程将会抢占较低优先级。

### 最早截止期限优先调度

截止期限越早，优先级越高

### 比例分享调度

采用准入控制策略，确保每个进程能够得到分配时间

### POSIX实时调度

