# 事务

- 标识事务开始

  ```mysql
  START TRANSACTION;
  ```

- 回滚该事务的SQL语句，也标识该事务的结束

  ```mysql
  START TRANSACTION;
  //SQL
  ROLLBACK;
  ```

- 提交该事务的SQL语句，也标识该事务结束

  ```mysql
  START TRANSACTION;
  //SQL
  COMMIT;
  ```

当COMMIT或ROLLBACK语句执行，事务会自动关闭

数据库的事务是一种机制，一个操作序列，包含了一组数据库操作命令，器质性结果必须式数据库从一种一致性状态编导另一种一致性状态。

## 特性

- 原子性

- 一致性

  多个事务对同一数据读取的结果相同

- 隔离性

  并发访问数据库时，一个用户的事务不被其他事务所干扰，哥哥事务不干涉内部的数据

- 持久性

  对数据的改变是持久的

使用日志保证原子性，一致性，持久性

使用锁来保证事务的隔离性

## 事务状态

- 活跃状态

  正在执行，所做的更改存储于主内存的缓冲区中。

- 部分提交状态

  部分执行完成，部分提交，根据主内存缓冲区

- 失败状态

  活动状态或部分提交状态发生一些错误

- 中止状态

- 提交状态

## 事务之间的相互影响

- 脏读

  一个事务读取了另一个事务未提交的数据。

  解决方法：在修改数据时，需要对数据进行加锁，避免其他事务读取到。读取已提交的隔离级别解决。

- 不可重复度读

  在一个事务范围内，两次相同的查询会返回两个不同的数据。

  原因：在两次间隙，其他事务的提交修改了某行数据。。

  可重复读的隔离级别解决。

- 幻读：

  在同一个事务范围内，表可能会突然增加新的行。
  
- 丢失更新

  相当于两个事务i=i+1，同时提交，会丢失一次增加。

## 事务隔离级别

- 读取未提交

  最低隔离级别，一个事务可以读到另一个事务未提交的结果，所有的并发问题都会发生。

  在修改数据前加锁。

- 读取已提交

  只有在事务提交后，其更新结果才会被其他事务看见。

  在读取事务前加锁，读取完毕后立刻解锁。

- 可重复读

  只可以读到事务开启前一刻的数据。

  行锁+MVCC

- 可串行化

  所有事务串行执行

# MVCC

InnoDB存储引擎在每行数据的后面添加了三个隐藏字段

## 辅助结构

### 隐藏字段

- 事务id（DB_TRX_ID）：6字节，标识最近一次对本行记录作修改的事务ID
- 回滚指针，指向当前记录行的undo log信息，也就是记录行的历史版本
- 行号：当表没有主键或唯一非空索引时，innodb就会使用行ID自动产生聚簇索引。

### ReadView结构

对本事务不可见的其他活跃事务

- trx_ids

  ReadView创建时其他未提交的活跃事务ID列表。

- low_limit_id

  目前出现的最大的事务ID+1，即下一个将被分配的事务ID

- up_limit_id

  活跃事务列表trx_ids中最小的事务id

### Undo log

存储的是老版本数据，当读取记录行时，如果当前记录行版本号不一致，可以顺着undo log链找到满足条件的版本

InnoDB里，undo log分为

- insert undo log：

  事务insert新纪录时产生。仅在事务回滚时需要，事务提交后立马丢弃。

- update undo log:

  事务对记录进行delete和update操作时产生。不仅在回滚时需要，快照读也需要。

## 记录行修改的具体流程

- 当前事务对记录行加排他锁。

- 把该行数据拷贝到undo log中，作为旧版本。
- 拷贝完毕后，修改该行的数据。
- 事务提交，提交签用CAS机制判断记录行当前最新修改的事务id是否发生了变化，如果变了回滚该事务。

## 记录行查询时的可见性计算

创建一个新事务后，执行第一个select语句的时候，innodb会创建一个快照(read view)，快照中会保存系统当前不应该被本事务看到的其他活跃事务id列表（trx_ids)。

当用户读取某一行时，比较这一行的trx_id和 low_limit_id和up_limit_id

- trx_id< up_limit_id 

  说明该行被修改于创建事务之前

- trx_id >=low_limit_id

  表明该行被修改于一个 新创建的事务

- up_limit_id<=trx_id<low_limit_id

  表明该行被read view 中的某个活跃事务提交了，说明未不可见，回滚指针找到上个记录行版本，判断是否可见。

## RR和RC的ReadView的实现过程区别

- 在innodb中的Repeatetavle Read级别，只有事务Begin后，执行第一条select才会创建一个快照
- 在innodb中的ReadCommitted级别，事务在begin之后，执行每条select时快照都会重置